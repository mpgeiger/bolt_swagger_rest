
Got it—here’s a ready-to-paste prompt for Bolt.new that will create a REST API called swagger-bolt. It converts a Swagger/OpenAPI JSON payload into a text/plain list of Bolt.new-style API descriptors.

⸻

Prompt for Bolt.new

Goal
Create a REST API endpoint that converts a Swagger/OpenAPI JSON document into a plain-text list of API descriptors in the following Bolt.new format, one block per operation:

API: <Human-readable API/operation title>
Endpoint: <Absolute URL or path>
Method: <HTTP METHOD>
Response:
	<example JSON pretty-printed and tab-indented>

Service name: swagger-bolt
Route: POST /api/swagger-bolt
Consumes: application/json (OpenAPI/Swagger v2 or v3 JSON)
Produces: text/plain; charset=utf-8
Description: Accepts an OpenAPI/Swagger JSON payload and returns a text list of Bolt.new-style API descriptors for each operation.

⸻

Input
	•	Body: A valid OpenAPI (v3.x) or Swagger (v2.0) JSON document.
	•	If YAML is sent accidentally, return 400 Bad Request with a friendly message stating JSON is required.

⸻

Output (strict)
	•	Content-Type: text/plain; charset=utf-8
	•	For each operation under paths, output exactly this block (separated by a blank line):

API: <Title>
Endpoint: <ResolvedEndpoint>
Method: <METHOD>
Response:
	<ExampleJson>

Where:
	•	<Title> resolution priority:
	1.	operation.summary if present and non-empty
	2.	operation.operationId if present
	3.	METHOD <path> (e.g., GET /pets/{id})
	•	<ResolvedEndpoint>:
	•	If servers[0].url (OAS v3) or host + basePath + schemes[0] (Swagger v2) exist, combine with the path (trim slashes).
	•	Otherwise output just the raw path (e.g., /v1/pets).
	•	<METHOD>: Uppercase HTTP verb (GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD).
	•	<ExampleJson>:
	•	Use a pretty-printed JSON example, tab-indented by one tab on every line.
	•	Choose the example for the first available 2xx response (prefer 200, else 201, else any 2xx), from:
	1.	content["application/json"].example
	2.	first item in content["application/json"].examples
	3.	schema.example
	4.	If none exist, generate a minimal JSON skeleton from the response schema (objects with properties → representative default values; arrays → one representative element).
	•	If there is no JSON media type or no schema, output {} as the example.

Formatting constraints
	•	The word Response: must be on its own line, followed by a newline, then the JSON block where every line begins with exactly one tab (\t).
	•	Keep one blank line between operation blocks. No extra text before or after.

⸻

Error handling
	•	400 Bad Request if:
	•	Body is empty or not valid JSON
	•	JSON is not a recognizable OpenAPI/Swagger document
	•	In 400 responses, return text/plain with a simple message:
	•	e.g., Body must contain a valid OpenAPI/Swagger JSON document.

⸻

Edge cases & rules
	•	If multiple servers are present, use the first.
	•	For relative server URLs, combine carefully with the path (avoid duplicate slashes).
	•	Support media types ending with +json (e.g., application/hal+json) as JSON.
	•	When generating skeletons:
	•	string → "string" (or ISO datetime for format: date-time, UUID for format: uuid)
	•	integer → 0
	•	number → 0
	•	boolean → false
	•	array → [ <skeleton of items> ] (one element)
	•	object → include keys with skeleton values (one level deep is fine)
	•	If a path has no JSON 2xx responses, still output the block with {} as the example.

⸻

Acceptance example (format reference)

Use this example to validate output formatting:

Given this descriptor example you must match:

API: Dog CEO – Random Dog Image
Endpoint: https://dog.ceo/api/breeds/image/random
Method: GET
Response:
	{
  		"message": "https://images.dog.ceo/breeds/hound-afghan/n02088094_1003.jpg",
  		"status": "success"
	}

Your output must follow the exact same structure and indentation.

⸻

Test payloads (for verification)

Minimal v3 skeleton

{
  "openapi": "3.0.3",
  "servers": [{ "url": "https://api.example.com/v1" }],
  "paths": {
    "/pets": {
      "get": {
        "summary": "List pets",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": { "type": "integer" },
                          "name": { "type": "string" }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "CreatePet",
        "responses": {
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "example": { "id": 1, "name": "Fido" }
              }
            }
          }
        }
      }
    }
  }
}

Expected output shape (not returned by the service—just a reference for you)

API: List pets
Endpoint: https://api.example.com/v1/pets
Method: GET
Response:
	{
		"items": [
			{
				"id": 0,
				"name": "string"
			}
		]
	}

API: CreatePet
Endpoint: https://api.example.com/v1/pets
Method: POST
Response:
	{
		"id": 1,
		"name": "Fido"
	}


⸻

Non-functional
	•	Keep runtime under a few hundred milliseconds for typical specs (<2MB).
	•	Memory-safe with large schemas: avoid deep recursion; cap skeleton depth to 2–3 levels if needed.

⸻

If you’d like, I can tailor this prompt to a specific runtime (e.g., “generate .NET 8 minimal API code” or “Node/TypeScript with Express/Fastify”)—but this version is ready to hand to Bolt.new as a high-level instruction to build the service.
